    //---------------------------------
    //---------------------------------
    //FUNCTIONS TO ALLOW LOCAL UNIT TESTS
    //---------------------------------
    //---------------------------------
    function testSetCompStatus(uint256 _compId) external {
        competitionTable[_compId].status = CompetitionStatus.inProgress;
    }

    function testCommenceCompetition(uint256 _compId) external onlyAdmin(msg.sender, _compId) {
        require(athleteListByComp[_compId].length >= 2, "Atleast two competitors required");

        //populate mapping with new competition struct
        competition = competitionTable[_compId];

        if (competition.status != CompetitionStatus.pending) {
            revert ChainRunners__CompStatusNotAsExpected(uint8(competition.status));
        }
        competitionIsLive[_compId] = true;

        for (uint8 i = 0; i < athleteListByComp[_compId].length; i++) {
            address[] memory listAthletes = athleteListByComp[_compId];
            //Add competition to the athletes competitions Array
            athleteToCompIdList[listAthletes[i]].push(uint8(_compId));
            //Call handleAPIRequest and pass athletes address
        }

        //set comp status to inprogress for testing
        competition.status = CompetitionStatus.inProgress;
    }

    function testHandleStartCompetition(uint8 _compId) external {
        if (competitionTable[_compId].status != CompetitionStatus.pending) {
            revert ChainRunners__CompStatusNotAsExpected(uint8(competitionTable[_compId].status));
        }
        //get competition Struct from mapping
        competition = competitionTable[_compId];
        // take fee
        uint256 _fee = (competition.totalStaked * 5) / 100;
        competition.totalStaked -= _fee;
        dappFee += _fee;
        //reward per payout Interval
        competition.rewardPot =
            (competition.totalStaked * 1 ether) /
            (competition.durationDays / competition.payoutIntervals);

        //Assign updated Competition Form back to mapping
        competitionTable[competitionId] = competition;
        handleStartCompetition(_compId);
    }

    function testPreformKeep() external {
        for (uint256 _compId = 1; _compId <= competitionId; _compId++) {
            CompetitionForm memory _competition = competitionTable[_compId];

            //check if competitionId is set to live on isLive mapping and due a payout event
            if (
                competitionIsLive[_compId] == true && block.timestamp >= _competition.nextPayoutDate
            ) {
                console.log("comp id is: ", _compId);
                //increment payoutId to reflect a new payout event triggered
                compPayoutId[_compId]++;
                apiCallBool[_compId] = true;
            }
        }
    }

    function testHandleAPICall(
        uint8 _requestType,
        address _athlete,
        string memory _stravaId,
        uint256 _compId
    ) external onlyOwner {
        //call consumer contract and pass address of athlete
        string[] memory args = new string[](1);
        args[0] = _stravaId;

        //need to think about the what to record and why
        i_linkReq.sendRequest(_requestType, args, _athlete, _compId);
    }

    function testReceiveAPIResponse(
        uint8 _requestType,
        address _athleteAddress,
        uint256 _distance
    ) external {
        testInteger = _distance;
        testAddress = _athleteAddress;
        requesttype = requestType(_requestType);
    }

    function testPayoutIdIncrement(uint256 _compId) external {
        compPayoutId[_compId]++;
    }

    function withdrawBalanceTEST() external onlyOwner {
        (bool sent, ) = msg.sender.call{value: address(this).balance}("");
        require(sent, "Unable to withdraw funds");
    }